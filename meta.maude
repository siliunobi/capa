load full-maude26

fmod TAG-COMMANDS is
    including COMMANDS .

    op tag_. : @ModExp@ -> @Command@ .
    
endfm 


fmod META-TAG-SIGNATURE is
	including META-FULL-MAUDE-SIGN .
	
	op TagGRAMMAR : -> FModule .
	eq TagGRAMMAR = addImports((including 'TAG-COMMANDS .), GRAMMAR ) .

endfm

fmod TAG-BUILTINS is
    including UNIT .
    including DATABASE-DECLS  .
    including EXT-QID-LIST .
    
    op tag : OModule -> OModule .
    op tagID : Qid -> Qid .
    
    
    var SM : SModule .
    var Q : Qid .
    var IL : ImportList .
    var S : SortSet .
    var SS : SubsortDeclSet .
    var CDS : ClassDeclSet .
    var SCDS : SubclassDeclSet .
    var O : OpDeclSet .
    var MS : MsgDeclSet .
    var M : MembAxSet .
    var E : EquationSet .
    var R : RuleSet .
    var DB : Database .
    
    eq tag(omod Q is
	  IL
    sorts S .
    SS
    CDS
    SCDS
    O
    MS
    M
    E
    R
endom) = omod tagID(Q)  is
IL
    sorts S .
    SS
    CDS
    SCDS 
    O
    MS
    M
    E
    tagRules(R)
endom .

    vars T T' : Term .
    var ATS : AttrSet .
    var CD : Condition .
    var ATR : AttrSet .
    var Rl : Rule .
    op tagRules : RuleSet  -> RuleSet .
    op tagRulesAux : Rule  -> RuleSet .
    
    ops newMonitorObj   : -> Term .
    ops newMonitorObjRecord : Term -> Term .
    ops resultMonitorObj : Term Term -> Term .
    ops resultMonitorObjInsert : Term Term Term Term Term -> Term .

    *** here are the functions to generate terms for tagged monitors
    *** I try to make them as generic as possible, but some paras are fixed for the simplicity 
    eq newMonitorObj = '<_:_|_>['M:Oid,'Monitor.Monitor,'_`,_['clock`:_['GT:Nat],'log`:_[
	      'LOG:Log]]] .

    eq newMonitorObj = '<_:_|_>['M:Oid,'Monitor.Monitor,'_`,_['clock`:_['GT:Nat],'log`:_[
	      'LOG:Log]]] .

    eq newMonitorObjRecord(T1) =
	'<_:_|_>['M:Oid,'Monitor.Monitor,'_`,_['clock`:_['GT:Nat],'log`:_[
	      '_`,_['_|->_[T1,'record['RID@M:Oid,'T1:Nat,'VTS1:VectorTimestamp,
		    'FFLAG:Bool,'READS:ReadSet,'WRITES:WriteSet]],'LOG:Log]]]] .

    eq resultMonitorObjInsert(T1,T2,T3,T4,T5) =
	'<_:_|_>['M:Oid,'Monitor.Monitor,'_`,_['clock`:_['_+_['GT:Nat,'s_[
		  '0.Zero]]],'log`:_['_`,_['_|->_[T1,'record['RID@M:Oid,'T1:Nat,
		    'insert[T2,'GT:Nat,'VTS1:VectorTimestamp],T3,T4,
		    T5]],'LOG:Log]]]] .
    
    
    eq resultMonitorObj(T1,T2) = '<_:_|_>['M:Oid,
	  'Monitor.Monitor,'_`,_['clock`:_['_+_['GT:Nat,'s_['0.Zero]]],'log`:_[
	      'insert[T1,'record[T2,'GT:Nat,'empty.VectorTimestamp,
		  'false.Bool,'empty.ReadSet,'empty.WriteSet],'LOG:Log]]]] .

    eq tagRules(Rl R) = tagRulesAux(Rl) tagRules(R)  .
    eq tagRules(none) = none . 

    ceq tagRulesAux(rl T => T' [ATR] .) = 
	(rl T1 => T2 [ATR] .)
      if '__[T1,T2] := tagLeftRightHand(T,T') .
    
    
    ceq tagRulesAux(crl T => T' if CD [ATR] .) =
	  (crl T1 => T2 if CD [ATR] .)
	  if '__[T1,T2] := tagLeftRightHand(T,T') .

    op getReplicaID : Term -> Variable .
    
    eq getReplicaID('<_:_|_>[V,'Replica.Replica,TL]) = V .
    eq getReplicaID('<_:_|`>[V,'Replica.Replica]) = V .
    eq getReplicaID(Q[TL]) = getReplicaID(TL) [owise] .
    ceq getReplicaID((T, TL)) = getReplicaID(T), getReplicaID(TL) if TL =/= empty . 
    eq getReplicaID(C) = empty .
    eq getReplicaID(V) = empty .
    
   op tagLeftRightHand : Term Term -> Term .


    vars Q' : Qid .
    vars T1 T2 T3 T4 T5 : Term .
    vars TL TL1 : TermList .

    *** reutrn the attribute value of a given attribute id 
    op getAttr : Qid Term -> Term .
    eq getAttr(Q,Q'[TL]) = if Q == Q' then TL else  getAttr(Q,TL) fi .

    ceq getAttr(Q,(T,TL)) =
	getAttr(Q,T), getAttr(Q,TL)        
      if TL =/= empty .
    
    eq getAttr(Q,empty) =
	empty .
    var V : Variable .
    var C : Constant .
    
    eq getAttr(Q,V) = empty .
    eq getAttr(Q,C) = empty .


    ops isExecuted isAborted isCommitted isSwitched : Term Term -> Bool .
    op  getTID : Term -> Term .
    ceq isExecuted(T, T') = true
	if T1 := getAttr('gotTxns`:_,T)  /\
          T2 := getAttr('executing`:_,T') /\
	  '<_:_|_>[T3,TL] := T2 /\    *** T3 is the TID of the executing tran 
	  is T3 subTermOf T1 .

    ceq getTID(T) = T3
	if T2 := getAttr('executing`:_,T) /\
	  '<_:_|_>[T3,TL] := T2 .

    ceq getTID(T) = T3
      if T2 := getAttr('executing`:_,T) /\
	  '<_:_|`>[T3,TL] := T2 . 
    
    ceq isCommitted(T, T') = true 
      if T1 := getAttr('executing`:_,T)  /\
	  '<_:_|_>[T3,TL] := T1 /\    *** T3 is the TID of the executing tran 
          T2 := getAttr('committed`:_,T') /\
	  is T3 subTermOf T2  .       

    ceq isAborted(T, T') = true 
      if T1 := getAttr('executing`:_,T)  /\
	  '<_:_|_>[T3,TL] := T1 /\    *** T3 is the TID of the executing tran 
          T2 := getAttr('aborted`:_,T') /\
	  is T3 subTermOf T2  .

      ceq isAborted(T, T') = true 
      if T1 := getAttr('executing`:_,T)  /\
	  '<_:_|`>[T3,TL] := T1 /\    *** T3 is the TID of the executing tran 
          T2 := getAttr('aborted`:_,T') /\
	  is T3 subTermOf T2  .
    
    ceq isSwitched(T,T') = true 
      if T1 := getAttr('recPropTxns`:_,T)  /\
	  '_;_['propagatedTxns[T3,TL],TL1] := T1 /\  *** T3 is the TID of the propagated tran 
          T2 := getAttr('locked`:_,T') /\   *** T2 is the locked trans 
	  is T3 subTermOf T2 .

    eq isAborted(T,T') = false [owise] .
    eq isCommitted(T,T') = false [owise] .
    eq isExecuted(T,T') = false [owise] .
    eq isSwitched(T,T') = false [owise] .
    
    op getPropagatedTxnsID : Term -> Term .

    ceq getPropagatedTxnsID(T) = T3
    if T1 := getAttr('recPropTxns`:_,T)  /\
	  '_;_['propagatedTxns[T3,TL],TL1] := T1 .      
          
    --- gotTxns -> executing
    --- condition : at left hand side executing is empty, right hand is not
    --- T: lefthand-side object
    --- T': righthand-side object
    --- DB: database 
    --- ceq tagLeftRightHand(T,T') =
    ---    '__['__[newMonitorObj,T],'__[resultMonitorObj,T']]
    ---  if getAttr('executing`:_,T) == 'emptyTxnList.ObjectList /\
    ---      getAttr('executing`:_,T') =/= 'emptyTxnList.ObjectList .

    --- this equation formalizes the execution of a transaction 
    ceq tagLeftRightHand(T,T') =
        '__['__[newMonitorObj,T],'__[resultMonitorObj(getTID(T'),getReplicaID(T)),T']]
      if not hasBranch(T') /\ isExecuted(T,T') .

    
      --- this equation formalizes the commit of a readonly transaction
    --- condition : the executing tran is committed (including fast)
  ceq tagLeftRightHand(T,T') =
        '__['__[newMonitorObjRecord(getTID(T)),T],
	  '__[resultMonitorObjInsert(getTID(T),
	      getReplicaID(T),'true.Bool,getAttr('readSet`:_,T1),getAttr('writeSet`:_,T1)),T']]
      if not hasBranch(T') /\ isCommitted(T,T') /\
	  T1 := getAttr('executing`:_,T) .       

      --- this equation formalizes the abort of a trans 
    --- condition : the executing tran is aborted
     ceq tagLeftRightHand(T,T') =
        '__['__[newMonitorObjRecord(getTID(T)),T],
	  '__[resultMonitorObjInsert(getTID(T),
	      getReplicaID(T),'false.Bool,'READS:ReadSet,'WRITES:WriteSet),T']]
      if not hasBranch(T') /\ isAborted(T,T')  .       

      --- this equation formalizes the abort of a trans 
    --- condition : the executing tran is aborted (including fast)
    --- ceq tagLeftRightHand(T,T') =
     ---   '__['__[newMonitorObjRecord(getTID(T)),T],
 ---	  '__[resultMonitorObjInsert(getTID(T),
	---      getReplicaID(T),'false.Bool,'READS:ReadSet,'WRITES:WriteSet),T']]
     --- if not hasBranch(T') /\ isAborted(T,T')  .       
    
    ceq tagLeftRightHand(T,T') =
        '__['__[newMonitorObjRecord(getTID(T)),T],
	    '__[newMonitorObjRecord(getTID(T)),T']]
      if not hasBranch(T') /\ not isAborted(T,T') /\
	  not isCommitted(T,T') /\ not isExecuted(T,T')
	  /\ not isSwitched(T,T')  . 

      
      
      --- this equation formalizes the switch of a trans 
      --- condition : the executing tran is committed (including fast)
    ceq tagLeftRightHand(T,T') =
        '__['__[newMonitorObjRecord(getPropagatedTxnsID(T)),T],
	  '__[resultMonitorObjInsert(getPropagatedTxnsID(T),
	      getReplicaID(T),'FFLAG:Bool,'READS:ReadSet,'WRITES:WriteSet),T']]
      if not hasBranch(T') /\ isSwitched(T,T')  .       

    ceq tagLeftRightHand(T, T') =
	'__['__[newMonitorObjRecord(getTID(T)),T],
	  tagRightHand(T, T')]
    if hasBranch(T') .

    op tagRightHand : Term TermList -> TermList .
    op hasBranch : TermList -> Bool .
    eq hasBranch('__[TL]) = hasBranch(TL) .
    eq hasBranch('if_then_else_fi[T1,T2,T3]) = true .
    ceq hasBranch((T, TL)) = hasBranch(T) or hasBranch(TL) if TL =/= empty .
    eq hasBranch(empty) = false .
    eq hasBranch(T) = false [owise] .


    ceq tagRightHand(T, (T', TL)) =
	(tagRightHand(T, T'), tagRightHand(T,TL))
      if TL =/= empty .
    eq tagRightHand(T, empty) = empty .
    
    eq tagRightHand(T,'__[TL]) = '__[tagRightHand(T, TL)] . 
    eq tagRightHand(T, 'if_then_else_fi[T1,T2,T3]) =
	'if_then_else_fi[T1,tagRightHand(T,T2),tagRightHand(T,T3)]  .

    ceq tagRightHand(T, '<_:_|_>[T1,'Replica.Replica,TL]) =
      T3 
      if '__[T2,T3] := tagLeftRightHand(T,'<_:_|_>[T1,'Replica.Replica,TL]) .
    
    eq tagRightHand(T, T') = T' [owise] .

      --- nothing changed, no tag

    eq tagLeftRightHand(T,T') =
        '__[T,T'] [owise] .


    

    eq tagID(Q) = string2qidList(string(Q) + "-TAGGED") .
    
endfm
    
    
mod TAG-DATABASE-HANDLING is
    protecting DATABASE-HANDLING .
    protecting META-TAG-SIGNATURE .    
    including TAG-BUILTINS .
    
    var N 				: Nat .
    var X@Database         : DatabaseClass .
    var O 				: Oid .
    var QI 				: Qid .
    vars QIL QIL' QIL''	        : QidList .
    vars T T' T''		        : Term .
    vars H H'			        : Header .
    var Q 				: Qid .
    vars DB DB' DB''           	: Database .
    var F					: Qid .
    vars MD M	M'	M''		: Module .
    var Atts 			        : AttributeSet .
    vars RP RP'			: ResultPair? .
    vars ME ME' ME''	                : ModuleExpression . 
    
    crl [handle-tag-func] : 
        < O         : X@Database | db : DB,
				   input     : ('tag_.[T]),
				   output  : nil, Atts > => 
        < O         : X@Database | db : DB'',
				   input     : nilTermList,
				    output : ('New 'module '\g Q '\o 'with 'monitors 'generated!),
				   Atts  >
      if  < DB' ; ME' > := evalModExp(parseModExp(T), DB) /\
	  M := getTopModule(ME', DB') /\ 
	  M' := tag(M) /\
	  Q := getName(M') /\ 
	  DB'' := insTermModule(Q,M',DB') .
endm 


mod TAG is
    extending LOOP-MODE .
    protecting TAG-DATABASE-HANDLING .
    
    subsort Object < State .
    op o : -> Oid .
    
    var H 				: Header .
    var O 				: Oid .
    var X@Database 		        : DatabaseClass .
    var QI 				: Qid .
    vars QIL QIL' QIL''             : QidList .
    var TL 				: TermList .
    var DB 				: Database .
    var Atts 			: AttributeSet .
    
    op init 			: -> System .
    
    
    
    rl [init] : init => [nil,
	  < o		: Database | 
	  db		: initialDatabase, 
	  input 	: nilTermList , 
          default      : 'CONVERSION ,
	  output 	: nil >,
	  ('\s '\s '\s '\s '\s '\g string2qidList("TAG Your Module") '\o)] .
    
    rl [input] : 	[QI QIL, 
	  < O 			: X@Database | 
	  input 		: nilTermList, 
	  output 		: nil, Atts >,  
	  QIL' ] => 
      if metaParse(TagGRAMMAR, QI QIL, '@Input@) :: ResultPair
	then
	  [nil, 
	    < O 			: X@Database | 
	    input 		: getTerm(metaParse(TagGRAMMAR, QI QIL, '@Input@)), 
	    output 		: nil, Atts >, 
	    QIL']
	else 
	  [nil, 
	    < O 			: X@Database | 
	    input 		: nilTermList, 
	    output 		: ('\r 'WARNING: '\o printSyntaxError(metaParse(TagGRAMMAR, QI QIL, '@Input@), QI QIL) '\n 
	      'ERROR: 'No 'parse 'for 'input.), Atts >, 
	    QIL' ]
	fi .
    
    rl 	[output] : 	[QIL, < O 		: X@Database | 
	  output 	: (QI QIL'), Atts >,
	  QIL''] =>
	[QIL, < O 		: X@Database | 
	  output 	: nil, Atts >, (QI QIL' QIL'')] .
endm

set print conceal on .

*** print conceal mod_is_sorts_._____endm .
*** print conceal fmod_is_sorts_.____endfm .
print conceal db .
    
loop init .
    
