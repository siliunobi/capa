 rl
< M:Address : Monitor | clock: GT:Nat,log:(TID:Address |-> < RID@M:Address |-> T1:Nat,VTS1:VectorTime,FFLAG:Bool,READS:Set{KeyVersion},WRITES:Set{KeyVersion}>, LOG:Log)>
< RID:Address : Replica | executing:
< TID:Address : Txn | readSet: RS:Set{KeyVersion},writeSet: WS:Set{KeyValue},version: VERSION:Version,AS:AttributeSet >,aborted: TXNS:ConfigList,voteSites:
    VSTS:VoteSites,AS':AttributeSet > msg prepare-reply(TID:Address,false)from RID':Address to RID:Address
    =>
< M:Address : Monitor | clock:(GT:Nat + 1),log:(TID:Address |-> < RID@M:Address |-> T1:Nat,insert(RID:Address,GT:Nat,VTS1:VectorTime),false,READS:Set{KeyVersion},
    WRITES:Set{KeyVersion}>, LOG:Log)>
< RID:Address : Replica | executing: noActor,aborted:(TXNS:ConfigList ;;
< TID:Address : Txn | readSet: RS:Set{KeyVersion},writeSet: WS:Set{KeyValue},version: VERSION:Version,AS:AttributeSet >),voteSites: remove(TID:Address,RID':Address,
    VSTS:VoteSites),AS':AttributeSet > start to RID:Address [label receive-prepare-reply-false-executing] .
  rl
< RID:Address : Replica | aborted:(TXNS:ConfigList ;;
< TID:Address : Txn | AS:AttributeSet > ;; TXNS':ConfigList),voteSites: VSTS:VoteSites,AS':AttributeSet > msg prepare-reply(TID:Address,FLAG:Bool)from RID':Address to
    RID:Address
    =>
< RID:Address : Replica | aborted:(TXNS:ConfigList ;;
< TID:Address : Txn | AS:AttributeSet > ;; TXNS':ConfigList),voteSites: remove(TID:Address,RID':Address,VSTS:VoteSites),AS':AttributeSet > [label
    receive-prepare-reply-aborted] .
  rl
< RID:Address : Replica | gotTxns: emptyTxnList,AS:AttributeSet > start to RID:Address
    =>
< RID:Address : Replica | gotTxns: emptyTxnList,AS:AttributeSet > [label receiving-start-when-no-txn-to-start] .
  crl
< M:Address : Monitor | clock: GT:Nat,log: LOG:Log >(start to RID:Address)
< TABLE:Address : Table | table: REPLICA-TABLE:ReplicaTable >
< RID:Address : Replica | gotTxns:(
< TID:Address : Txn | operations: OPS:OperationList,latest: empty,AS:AttributeSet > ;; TXNS:ConfigList),executing: noActor,1stGetSites: 1STGETS:1stGets,AS':AttributeSet >
    =>
< M:Address : Monitor | clock:(GT:Nat + 1),log: insert(TID:Address,< RID:Address |-> GT:Nat,empty,false,empty,empty >,LOG:Log)>
< TABLE:Address : Table | table: REPLICA-TABLE:ReplicaTable >
< RID:Address : Replica | gotTxns: TXNS:ConfigList,executing:
< TID:Address : Txn | operations: OPS:OperationList,latest: vl(OPS:OperationList),AS:AttributeSet >,1stGetSites:(1STGETS:1stGets ; 1st(TID:Address,RIDS:AddressSet)),
    AS':AttributeSet > genGets(OPS:OperationList,RID:Address,TID:Address,REPLICA-TABLE:ReplicaTable)
    if not write-only(OPS:OperationList)= true /\ RIDS:AddressSet := 1stSites(OPS:OperationList,RID:Address,REPLICA-TABLE:ReplicaTable) [label start-ro-or-rw-txn] .
  crl
< M:Address : Monitor | clock: GT:Nat,log: LOG:Log >(start to RID:Address)
< TABLE:Address : Table | table: REPLICA-TABLE:ReplicaTable >
< RID:Address : Replica | gotTxns:(
< TID:Address : Txn | operations: OPS:OperationList,localVars: VARS:LocalVars,txnSQN: TXNSQN:Int,writeSet: WS:Set{KeyValue},version: VERSION:Version,AS:AttributeSet > ;;
    TXNS:ConfigList),executing: noActor,sqn: SQN:Int,voteSites: VSTS:VoteSites,AS':AttributeSet >
    =>
< M:Address : Monitor | clock:(GT:Nat + 1),log: insert(TID:Address,< RID:Address |-> GT:Nat,empty,false,empty,empty >,LOG:Log)>
< TABLE:Address : Table | table: REPLICA-TABLE:ReplicaTable >
< RID:Address : Replica | gotTxns: TXNS:ConfigList,executing:
< TID:Address : Txn | operations: OPS:OperationList,localVars: VARS:LocalVars,txnSQN: SQN':Int,writeSet: WS':Set{KeyValue},version: < RID:Address,SQN':Int >,
    AS:AttributeSet >,sqn: SQN':Int,voteSites:(VSTS:VoteSites ; voteSites(TID:Address,RIDS:AddressSet)),AS':AttributeSet > genPuts(OPS:OperationList,RID:Address,
    TID:Address,SQN':Int,VARS:LocalVars,REPLICA-TABLE:ReplicaTable)
    if SQN':Int := SQN:Int + 1 /\ write-only(OPS:OperationList)= true /\ RIDS:AddressSet := prepareSites(OPS:OperationList,RID:Address,REPLICA-TABLE:ReplicaTable)/\
    WS':Set{KeyValue}:= ws(OPS:OperationList,VARS:LocalVars) [label start-wo-txn] .
 

  crl
< M:Address : Monitor | clock: GT:Nat,log:(TID:Address |-> < RID@M:Address |-> T1:Nat,VTS1:VectorTime,FFLAG:Bool,READS:Set{KeyVersion},WRITES:Set{KeyVersion}>, LOG:Log)>
< TABLE:Address : Table | table: REPLICA-TABLE:ReplicaTable >
< RID:Address : Replica | executing:
< TID:Address : Txn | operations: OPS:OperationList,txnSQN: TXNSQN:Int,AS:AttributeSet >,voteSites: VSTS:VoteSites,sqn: SQN:Int,commitSites: CMTS:VoteSites,
    AS':AttributeSet > msg prepare-reply(TID:Address,true)from RID':Address to RID:Address
    =>
< TABLE:Address : Table | table: REPLICA-TABLE:ReplicaTable > if VSTS':VoteSites[TID:Address]==(empty).AddressSet then
< RID:Address : Replica | executing:
< TID:Address : Txn | operations: OPS:OperationList,txnSQN: TXNSQN:Int,AS:AttributeSet >,voteSites: VSTS':VoteSites,sqn: SQN:Int,commitSites:(CMTS:VoteSites ; voteSites(
    TID:Address,RIDS:AddressSet)),AS':AttributeSet > genCommits(TID:Address,TXNSQN:Int,RIDS:AddressSet,RID:Address)else
< RID:Address : Replica | executing:
< TID:Address : Txn | operations: OPS:OperationList,txnSQN: TXNSQN:Int,AS:AttributeSet >,voteSites: VSTS':VoteSites,sqn: SQN:Int,commitSites: CMTS:VoteSites,
    AS':AttributeSet > fi
    if VSTS':VoteSites := remove(TID:Address,RID':Address,VSTS:VoteSites)/\ RIDS:AddressSet := prepareSites(OPS:OperationList,RID:Address,REPLICA-TABLE:ReplicaTable) [
    label receive-prepare-reply-true-executing] .


  crl
< RID:Address : Replica | datastore: VS:Versions,sqn: SQN:Int,tsSqn: TSSQN:TimestampSqn,AS':AttributeSet > msg prepare(TID:Address,version(K:Key,V:Value,TS:Timestamp,
    MD:KeySet))from RID':Address to RID:Address
    =>
< RID:Address : Replica | datastore:(VS:Versions version(K:Key,V:Value,TS:Timestamp,MD:KeySet)),sqn: SQN':Int,tsSqn: insert(TS:Timestamp,SQN':Int,TSSQN:TimestampSqn),
    AS':AttributeSet > msg prepare-reply(TID:Address,true)from RID:Address to RID':Address
    if SQN':Int := SQN:Int + 1 [label receive-prepare-wo] .
  crl
< RID:Address : Replica | datastore: VS:Versions,sqn: SQN:Int,tsSqn: TSSQN:TimestampSqn,AS':AttributeSet > msg prepare(TID:Address,version(K:Key,V:Value,TS:Timestamp,
    MD:KeySet),TS':Timestamp)from RID':Address to RID:Address
    => if tstamp(VERSION:Version)== eptTS or tstamp(VERSION:Version)== TS':Timestamp then
< RID:Address : Replica | datastore:(VS:Versions version(K:Key,V:Value,TS:Timestamp,MD:KeySet)),sqn: SQN':Int,tsSqn: insert(TS:Timestamp,SQN':Int,TSSQN:TimestampSqn),
    AS':AttributeSet > msg prepare-reply(TID:Address,true)from RID:Address to RID':Address else
< RID:Address : Replica | datastore: VS:Versions,sqn: SQN:Int,tsSqn: TSSQN:TimestampSqn,AS':AttributeSet > msg prepare-reply(TID:Address,false)from RID:Address to
    RID':Address fi
    if SQN':Int := SQN:Int + 1 /\ VERSION:Version := latestPrepared(K:Key,VS:Versions) [label receive-prepare-rw] .
endm