load cassandra-aux

mod CASSANDRA is
  inc CASSANDRA-AUX .

  var K : Key .  vars V V' : Value .  var CL : ConsistLevel .
  var RPS : Set{RingPair} .  var LOCKS : Set{LockedKey} .  var OP : Operation .
  vars O TID RID A A' S S' : Address . vars AS AS' : AttributeSet .
  vars TXNS TXNS' : Config .  vars TRANSES TRANSES' : ConfigList . 
  var GT : Nat .  vars VERSION VERSION' : Version .
  var WS : Set{KeyValue} .  var RS : Set{KeyVersion} . 
  var RESPONSES : Responses . var RCL : ReqConsLv .
  var RIDS : Set{Address} . var DS : Set{KeyValueVersion} .
  var RSET : ResponseSet . vars KVV KVV' : KeyValueVersion .  var FLAG : Bool . 


  rl [dequeue] :
     < A : Client | requestQueue: (< TID : Txn | operations: OP, AS' > ;; TRANSES),
                       waitingList: TRANSES',
                       lockedKeys: LOCKS,
                       executing: TXNS, AS > 
   =>
     if isLocked(OP,LOCKS)
       then < A : Client | requestQueue: TRANSES,
                              waitingList: (TRANSES' ;; < TID : Txn | operations: OP, AS' >),
                              lockedKeys: LOCKS,
                              executing: TXNS, AS >  
       else < A : Client | requestQueue: TRANSES,
                              waitingList: TRANSES',
                              lockedKeys: (lock(TID,OP),LOCKS),
                              executing: (< TID : Txn | operations: OP, AS' > TXNS), AS > 
     fi .




 crl [waiting-dequeue] :
     < A : Client | waitingList: (TRANSES ;; < TID : Txn | operations: OP, AS' > ;; TRANSES'),
                       lockedKeys: LOCKS,
                       executing: TXNS, AS > 
   =>
     < A : Client | waitingList: (TRANSES ;; TRANSES'),
                       lockedKeys: (lock(TID,OP),LOCKS),
                       executing: (< TID : Txn | operations: OP, AS' > TXNS), AS > 
     if not isLocked(OP,LOCKS) .


  rl [read-from-client-to-coord] :
     < A : Client | executing: (< TID : Txn | operations: read(K),
                                              consLv: CL, AS' > TXNS),
                    currentServer: S, AS >
   =>
     < A : Client | executing: (< TID : Txn | operations: read(K),
                                              consLv: CL, AS' > TXNS),
                    currentServer: S, AS >
     (msg request(TID,read(K),CL) from A to S) .


  rl [write-from-client-to-coord] :
     < O : Timer | globeTime: GT >
     < A : Client | executing: (< TID : Txn | operations: write(K,V),
                                              consLv: CL, 
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    currentServer: S, AS >
   =>
     < O : Timer | globeTime: (GT + 1) >
     < A : Client | executing: (< TID : Txn | operations: write(K,V),
                                              consLv: CL,
                                              writeSet: (WS,< K,V >),
                                              version: (GT + 1), AS' > TXNS),
                    currentServer: S, AS >
     (msg request(TID,write(K,V),GT + 1,CL) from A to S) .


  rl [read-from-coord-to-repl] :
     < S : Server | localRing: RPS,
                    reqConsLv: RCL,
                    respFromRepl: RESPONSES, AS >
     (msg request(TID,read(K),CL) from A to S)
   => 
     < S : Server | localRing: RPS,
                    reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: insert(TID,empty,RESPONSES), AS > 
     genReadRequests(TID,K,nextNAddresses([K],RPS,3),S) . 

  op genReadRequests : Address Key Set{Address} Address -> Config .
  eq genReadRequests(TID,K,(RID,RIDS),S) = 
       (msg readRequest(TID,K) from S to RID) 
       genReadRequests(TID,K,RIDS,S) .
  eq genReadRequests(TID,K,empty,S) = null .


  rl [write-from-coord-to-repl] :
     < S : Server | localRing: RPS,
                    reqConsLv: RCL,
                    respFromRepl: RESPONSES, AS >
     (msg request(TID,write(K,V),GT,CL) from A to S) 
   => 
     < S : Server | localRing: RPS,
                    reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: insert(TID,empty,RESPONSES), AS > 
     genWriteRequests(TID,K,V,GT,nextNAddresses([K],RPS,3),S) . 

  op genWriteRequests : Address Key Value Version Set{Address} Address -> Config .
  eq genWriteRequests(TID,K,V,VERSION,(RID,RIDS),S) = 
       (msg writeRequest(TID,[K,V,VERSION]) from S to RID) 
       genWriteRequests(TID,K,V,VERSION,RIDS,S) .
  eq genWriteRequests(TID,K,V,VERSION,empty,S) = null .


  rl [read-from-repl-to-coord] :
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     (msg readRequest(TID,K) from S to RID)
   => 
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     (msg readResponse(TID,[K,V,VERSION]) from RID to S) .


  rl [write-from-repl-to-coord] :
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     (msg writeRequest(TID,[K,V',VERSION']) from S to RID)
   => 
     if VERSION' >= VERSION
       then < RID : Server | datastore: (DS, [K,V',VERSION']), AS >
            (msg writeResponse(TID,true) from RID to S)
       else < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
            (msg writeResponse(TID,false) from RID to S)
     fi .


 rl [read-at-coord] : 
     < S : Server | respFromRepl: (TID |-> RSET,RESPONSES), AS >
     (msg readResponse(TID,KVV) from RID to S) 
   =>
     < S : Server | respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS > .


 rl [write-at-coord] : 
     < S : Server | respFromRepl: (TID |-> RSET,RESPONSES), AS >
     (msg writeResponse(TID,FLAG) from RID to S) 
   =>
     < S : Server | respFromRepl: (TID |-> (response(RID,FLAG),RSET),RESPONSES), AS > .



 crl [from-coord-to-client-readrepair] : 
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
   =>
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
     genReadRepairs((response(RID,KVV),RSET),S)
     if CL == 3
       then done(TID,resultForRead((response(RID,KVV),RSET)))
       else null 
     fi
     if | (response(RID,KVV),RSET) | == 3 .   

  op genReadRepairs : ResponseSet Address -> Config .
  eq genReadRepairs(RSET,S) = 
       $genReadRepairs(resultForRead(RSET),repairReplicas(resultForRead(RSET),RSET),S) .
  
  op $genReadRepairs : KeyValueVersion Set{Address} Address -> Config .
  eq $genReadRepairs(KVV,(RID,RIDS),S) =
       (msg readRepair(KVV) from S to RID)
       $genReadRepairs(KVV,RIDS,S) .
  eq $genReadRepairs(KVV,empty,S) = null .



  rl [readrepair] :
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     (msg readRepair([K,V',VERSION']) from S to RID)
   => 
     if VERSION' >= VERSION
       then < RID : Server | datastore: (DS, [K,V',VERSION']), AS >
       else < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     fi .


 crl [from-coord-to-client] : 
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
   =>
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
     done(TID,resultForRead((response(RID,KVV),RSET)))
     if | (response(RID,KVV),RSET) | =/= 3 /\
        | (response(RID,KVV),RSET) | == CL .  



 crl [from-coord-to-client-write] : 
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,FLAG),RSET),RESPONSES), AS >
   =>
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,FLAG),RSET),RESPONSES), AS >
     done(TID,resultForWrite((response(RID,FLAG),RSET)))
     if CL == | (response(RID,FLAG),RSET) | .   



  rl [rcv-done-read] :
     < A : Client | executing: (< TID : Txn | readSet: RS,
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    committed: TXNS', 
                    lockedKeys: (lockedKey(TID,K),LOCKS), AS >
     done(TID,[K,V,VERSION'])
   =>
     < A : Client | executing: TXNS,
                    committed: (TXNS' < TID : Txn | readSet: (RS,< K,VERSION' >),
                                                    writeSet: WS,
                                                    version: VERSION, AS' >), 
                    lockedKeys: LOCKS, AS > .


  rl [rcv-done-write] :
     < A : Client | executing: (< TID : Txn | readSet: RS,
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    committed: TXNS',
                    lockedKeys: (lockedKey(TID,K),LOCKS), AS >
     done(TID,FLAG)
   =>
     < A : Client | executing: TXNS,
                    committed: (TXNS' < TID : Txn | readSet: RS,
                                                    writeSet: WS,
                                                    version: VERSION, AS' >),
                    lockedKeys: LOCKS, AS > .

endm

