  --- Is history a sorted list? 
  --- Section 5.3, what does "last upate" mean? Last in list order, or in time?
  --- When initializing VTS, all replicas know each other, i.e., each replica holds
  --- the same length of vector, or VTS is simply set to empty?
  --- As of now, we implement the latter

load replica-table

(omod WALTER is
  including CLIENT-REPLICA .
  including MESSAGE .
  including REPLICA-TABLE .
  including VERSION-WALTER .
  including VALUES-NAT .

  op f : -> Nat .  --- disaster-safe tolerance parameter

  vars TID RID RID' TABLE M : Oid .
  vars RIDS DSTXNS GVTXNS : OidSet .
  vars TXNS TXNS' TXNS'' : ObjectList .
  var OPS : OperationList .
  var K : Key .
  vars V V' : Value .
  var X : LocalVar .
  var WS : WriteSet .
  var VARS : LocalVars .
  vars RS READS WRITES : ReadSet .
  var REPLICA-TABLE : ReplicaTable .
  var VERSION : Version .
  vars VTS VTS' VTS'' VTS1 : VectorTimestamp .
  vars DS DS' : Datastore .
  vars VVS VVS' : ValueVersionList .
  vars SQN SQN' TXNSQN CLOCK GT T1 T2 T3 T4 : Nat .
  var EXPR : Expression .
  var KS : KeySet .
  var LOCKS : Locks .
  vars VSTS VSTS' VSBS VSBS' ABORTS ABORTS' : VoteSites .
  vars RIDSS RIDSS' : OidList .
  var RT : KeyReplicas .
  vars VOTES VOTES' : Vote .
  var FLAG : Bool .
  vars PSTS PSTS' : PropagateSites .
  vars PTXNS PTXNS' PTXNS'' : PropagatedTxns .
  vars DTXNS DTXNS' : DurableTxns .
  var LOG : Log .


  --- choose the last update in the history visible to startVTS
  op choose : VectorTimestamp ValueVersionList -> ValueVersion .
  eq choose(VTS,(VVS < V,version(RID,SQN) >)) = 
       if VTS[RID] == 0
         then choose(VTS,VVS)
         else if SQN <= VTS[RID]
                then < V,version(RID,SQN) >
                else choose(VTS,VVS)
              fi 
       fi [owise] .
  --- as of now we return default value if none found
  --- namely, < [0], version(0,0) >
  --- assume the initial sqn is 0
  eq choose(VTS,nil) = < [0], version(0,0) > .
  eq choose(empty,VVS) = < [0],version(0,0) > .  --- the first incoming read 
  eq choose(VTS,undefined) = < [0], version(0,0) > .


  ---??? the explanation of "merge" in the Walter paper is vague...
  op merge : Key ValueVersion Datastore -> Datastore .
  eq merge(K,< V,VERSION >,(K |-> (VVS < V,VERSION > VVS'),DS)) = K |-> (VVS < V,VERSION > VVS'),DS .
 ceq merge(K,< V,VERSION >,(K |-> VVS,DS)) = K |-> (VVS < V,VERSION >),DS 
       if (not occurs(< V,VERSION >, VVS)) .
  eq merge(K,< V,VERSION >,DS) = K |-> < V,VERSION >, DS [owise] .  


  op modified : WriteSet VectorTimestamp Datastore -> Bool .
 ceq modified((K |-> V,WS),VTS,(K |-> (VVS < V',version(RID,SQN) > VVS'),DS)) = true
       if SQN > VTS[RID] .
  eq modified(WS,VTS,DS) = false [owise] .

  op modified : KeySet VectorTimestamp Datastore -> Bool .
 ceq modified((K,KS),VTS,(K |-> (VVS < V',version(RID,SQN) > VVS'),DS)) = true
       if SQN > VTS[RID] .
  eq modified(KS,VTS,DS) = false [owise] .

  op locked : WriteSet Locks -> Bool .
  eq locked((K |-> V,WS),(lock(TID,K),LOCKS)) = true .
  eq locked(WS,LOCKS) = false [owise] .
 
  op locked : KeySet Locks -> Bool .
  eq locked((K,KS),(lock(TID,K),LOCKS)) = true .
  eq locked(KS,LOCKS) = false [owise] .

  op update : WriteSet Version Datastore -> Datastore .
  eq update((K |-> V,WS),version(RID,SQN),(K |-> VVS,DS)) = 
       update(WS,version(RID,SQN),(K |-> (VVS < V,version(RID,SQN) >),DS)) .
  eq update((K |-> V,WS),version(RID,SQN),DS) = 
       update(WS,version(RID,SQN),(K |-> < V,version(RID,SQN) >,DS)) [owise] .
  eq update(empty,VERSION,DS) = DS .

  op kvs : WriteSet Version -> ReadSet .
  eq kvs((K |-> V,WS),VERSION) = 
       kvs(WS,VERSION), versionRead(K,VERSION) .
  eq kvs(empty,VERSION) = empty .

  
  ---??? Fig.13 in the walter paper says propagating a txn to ALL servers, why ALL?
  ---??? shouldn't all replicas concerning keys in the write set be enough?
  ---??? As explained in Section 4.4, ALL is for disaster-safe durability
  op propagateTxn : Oid Nat VectorTimestamp WriteSet OidSet Oid -> Configuration .
  eq propagateTxn(TID,SQN,VTS,WS,(RID, RIDS),RID') = 
       propagateTxn(TID,SQN,VTS,WS,RIDS,RID')
       (msg propagate(TID,SQN,VTS,WS) from RID' to RID) .
  eq propagateTxn(TID,SQN,VTS,WS,empty,RID') = none .
  

  --- Walter runs 2pc among preferred sites of updated objects
  --- the key set sent to a server is a subset of the entire key set where each key's 
  --- preferred site is that server
  op prepareTxn : Oid KeySet VectorTimestamp OidSet ReplicaTable Oid -> Configuration .
  eq prepareTxn(TID,KS,VTS,(RID, RIDS),REPLICA-TABLE,RID') =
       prepareTxn(TID,KS,VTS,RIDS,REPLICA-TABLE,RID')
       (msg prepare(TID,onSite(KS,RID,REPLICA-TABLE),VTS) from RID' to RID) .
  eq prepareTxn(TID,KS,VTS,empty,REPLICA-TABLE,RID') = none .
  


  op onSite : KeySet Oid ReplicaTable -> KeySet .
  eq onSite((K,KS),RID,[replicatingSites(K,RID RIDSS) ;; RT]) = 
       K, onSite(KS,RID,[RT]) .
  eq onSite(KS,RID,[RT]) = empty [owise] .
  
  op propagateAbort : Oid OidSet Oid -> Configuration .
  eq propagateAbort(TID,(RID, RIDS),RID') = 
       propagateAbort(TID,RIDS,RID')
       (msg abort(TID) from RID' to RID) .
  eq propagateAbort(TID,empty,RID') = none .
  
  
  op addLock : KeySet Oid -> Locks .
  eq addLock((K,KS),TID) = lock(TID,K), addLock(KS,TID) .
  eq addLock(empty,TID) = empty . 

  op release : Oid Locks -> Locks .
  eq release(TID,(lock(TID,K),LOCKS)) =
       release(TID,LOCKS) .
  eq release(TID,LOCKS) = LOCKS [owise] .

  op remove : Oid Oid VoteSites -> VoteSites .
  eq remove(TID,RID,(voteSites(TID,(RID, RIDS)) ; VSTS)) =
       voteSites(TID,RIDS) ; VSTS .
  eq remove(TID,RID,VSTS) = VSTS [owise] .
  
  op _`[_`] : VoteSites Oid -> OidSet .
  eq (voteSites(TID,RIDS) ; VSTS)[TID] = RIDS . 

  op yesSites : Oid Vote -> OidSet .
  eq yesSites(TID,(vote(TID,RID',true) ; VOTES)) = RID', yesSites(TID,VOTES) .
  eq yesSites(TID,VOTES) = empty [owise] .

  op allYes : Oid Vote -> Bool .
  eq allYes(TID,(vote(TID,RID',false) ; VOTES)) = false .
  eq allYes(TID,VOTES) = true [owise] .

  op txnPropagateSites : Oid WriteSet -> PropagateSites .
  eq txnPropagateSites(TID,(K |-> V,WS)) = 
       propagateSites(TID,K,empty) ; txnPropagateSites(TID,WS) .
  eq txnPropagateSites(TID,empty) = noPS . 
  
  op dsDurable : Oid PropagateSites -> Bool .  --- filter for TID
  eq dsDurable(TID,(propagateSites(TID,K,RIDS) ; PSTS)) = | RIDS | >= (f + 1) and dsDurable(TID,PSTS) .
  eq dsDurable(TID,PSTS) = true [owise] .

  op add : Oid KeySet Oid ReplicaTable PropagateSites -> PropagateSites .  --- TID, RID
  eq add(TID,(K,KS),RID,[replicatingSites(K,RIDSS RID RIDSS') ;; RT],(propagateSites(TID,K,RIDS) ; PSTS)) =
       add(TID,KS,RID,[RT],(propagateSites(TID,K,(RID,RIDS)) ; PSTS)) .
  eq add(TID,KS,RID,[RT],PSTS) = PSTS [owise] .

  
  op dsDurableTxn : Oid OidSet Oid -> Configuration .
  eq dsDurableTxn(TID,(RID,RIDS),RID') =
       dsDurableTxn(TID,RIDS,RID')
       (msg ds-durable(TID) from RID' to RID) .
  eq dsDurableTxn(TID,empty,RID') = none .
  

  ---??? the walter paper doesn't mention how to compare two VectorTimestamps
  ---??? so I define based on my understanding
  op _gt_ : VectorTimestamp VectorTimestamp -> Bool .
 ceq ((RID |-> SQN), VTS) gt ((RID |-> SQN'), VTS') = false 
       if SQN < SQN' .
 ceq VTS gt ((RID |-> SQN'), VTS') = false
       if not $hasMapping(VTS,RID) .  
  eq VTS gt VTS' = true [owise] .

  
  op _in_ : Oid PropagatedTxns -> Bool .
  eq TID in (propagatedTxns(TID,SQN,VTS) ; PTXNS) = true .
  eq TID in (nonPropagatedTxns(TID,SQN,VTS,WS,RID') ; PTXNS) = true .
  eq TID in PTXNS = false [owise] .

  op _in_ : Oid VoteSites -> Bool .
  eq TID in (voteSites(TID,RIDS) ; VSTS) = true .
  eq TID in VSTS = false [owise] .

  ---
  --- "gotTxns" abstracts "client" away
  rl [start-txn] :
     < M : Monitor | clock : GT, log : LOG >
     < RID : Replica | gotTxns : (< TID : Txn | startVTS : empty > ;; TXNS), 
                       executing : emptyTxnList, committedVTS : VTS >
   =>
     < M : Monitor | clock : GT + 1, log : insert(TID,record(RID,GT,empty,false,empty,empty),LOG) >
     < RID : Replica | gotTxns : TXNS,
                       executing : < TID : Txn | startVTS : VTS >, 
                       committedVTS : VTS > .


  rl [execute-read-own-write] :
     < RID : Replica | executing : < TID : Txn | operations : ((X :=read K) OPS),
                                                 writeSet : (K |-> V, WS),
                                                 localVars : VARS > >
   =>
     < RID : Replica | executing : < TID : Txn | operations : OPS, writeSet : (K |-> V, WS),
                                                 localVars : insert(X,V,VARS) > > .

  --- ??? A server's history may have ValueVersions of K even if K is not replicated at the server
  --- ??? Thus we need to check replica-table
 crl [execute-read-local] :
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : ((X :=read K) OPS),
                                                 writeSet : WS, readSet : RS,
                                                 localVars : VARS, startVTS : VTS >, 
                       history : DS >
   =>
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : OPS, writeSet : WS,
                                                 readSet : (versionRead(K,VERSION),RS),
                                                 localVars : insert(X,V,VARS),
                                                 startVTS : VTS >, 
                       history : DS >
     if (not $hasMapping(WS,K)) /\ localReplica(K,RID,REPLICA-TABLE) /\
        < V,VERSION > := choose(VTS,DS[K]) .

 crl [execute-read-remote] :
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : ((X :=read K) OPS),
                                                 writeSet : WS, startVTS : VTS > >
   =>
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : (waitRemote(K,X) OPS),
                                                 writeSet : WS, startVTS : VTS > >
     (msg request(K,TID,VTS) from RID to RID')
     if (not $hasMapping(WS,K)) /\ (not localReplica(K,RID,REPLICA-TABLE)) /\
        RID' := preferredSite(K,REPLICA-TABLE) .  --- returns the preferred site of K, not a set of sites in GDUR

  crl [receive-remote-request] :
      < RID : Replica | history : DS >
      (msg request(K,TID,VTS) from RID' to RID)
    =>
      < RID : Replica | history : DS >
      (msg reply(TID,K,< V,VERSION >) from RID to RID')
      if < V,VERSION > := choose(VTS,DS[K]) .

  --- ??? Walter MERGES the fetched data with any updates in the local history
  --- ??? and in writeSet. But how???
  --- ??? My current understanding is that the fetched value will be in readSet for possible later writes
  --- ??? in the same txn; probably no need to update history at this moment because when slowCommit,
  --- ??? the version will be add to history 
  --- ??? Another point is that the fetched value is already checked by "choose", so it will not affect
  --- ??? the "unmodified" check in fastCommit
  --- ??? Anyway, as of now, we define "merge" 
   rl [receive-remote-reply] :
      < RID : Replica | executing : < TID : Txn | operations : (waitRemote(K,X) OPS),
                                                  readSet : RS, localVars : VARS >,
                        history : DS >
      (msg reply(TID,K,< V,VERSION >) from RID' to RID)
    =>
      < RID : Replica | executing : < TID : Txn | operations : OPS,
                                                  readSet : (versionRead(K,VERSION),RS),
                                                  localVars : insert(X,V,VARS) >,
                        history : merge(K,< V,VERSION >,DS) > .

  rl [execute-write] :
     < RID : Replica | executing : < TID : Txn | operations : (write(K,EXPR) OPS),
                                                 localVars : VARS, writeSet : WS > >
   =>
     < RID : Replica | executing : < TID : Txn | operations : OPS, localVars : VARS,
                                                 writeSet : insert(K,eval(EXPR,VARS),WS) > > . 

  --- ??? My understanding is to simply commit read-only txns  
   rl [commit-read-only-txn] :
      < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
      < RID : Replica | executing : < TID : Txn | operations : nil, writeSet : empty,
                                                  readSet : RS >, 
                        committed : TXNS' >
    =>
      < M : Monitor | clock : GT + 1, log : (TID |-> record(RID,T1,insert(RID,GT,VTS1),true,RS,empty),LOG) >
      < RID : Replica | executing : emptyTxnList, 
                        committed : (TXNS' ;; < TID : Txn | operations : nil, 
                                                            writeSet : empty, readSet : RS >) > .

  --- ??? We do not need "submitted" because txns are executed in order
  --- ??? Thus unless the txn is decided it is safe to leave it in "executing"
  --- ??? "wait until" in the walter paper says walter waits until the local txn with preceding
  --- ??? sqn has been committed. Since we assume txns from the same server are executed in order,
  --- ??? I don't see any case that "wait until" applies???
  --- ??? So we implement as instant commit if unmodified and unlocked
 crl [fast-commit-success] :  --- committedVTS[i] = x.sqn-1
     < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : nil,
                                                 readSet : RS,
                                                 writeSet : WS,
                                                 startVTS : VTS,
                                                 txnSQN : TXNSQN >, 
                       committed : TXNS', history : DS,  
                       locked : LOCKS, sqn : SQN, 
                       committedVTS : VTS', dsSites : PSTS >
   =>
     < M : Monitor | clock : GT + 1, log : (TID |-> record(RID,T1,insert(RID,GT,VTS1),true,RS,kvs(WS,version(RID,SQN'))),LOG) >
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : emptyTxnList,
                       committed : (TXNS' ;; < TID : Txn | operations : nil,
                                                           readSet : RS,
                                                           writeSet : WS,
                                                           startVTS : VTS, 
                                                           txnSQN : SQN' >),
                       history : DS', locked : LOCKS,
                       sqn : SQN', committedVTS : VTS'', dsSites : PSTS' >
     propagateTxn(TID,SQN',VTS,WS,allServers(REPLICA-TABLE),RID)  
     ---??? propagate to ALL servers, not just all replicas concerning the keys in writeSet
     ---??? according to Section 4.3 in the walter paper
     ---??? I doubt what I said above: it should be all replicas concerning the keys in writeSet
     ---??? because the owise replica will do nothing upon receiving the propagate msg
     ---??? also, section 4.3 talks about a txn can be committed at the server where it is not replicated
     ---??? it has nothing to do with propagate, but only commit 
     if WS =/= empty /\
        allLocalPreferred(WS,RID,REPLICA-TABLE) /\
        (not modified(WS,VTS,DS)) /\
        (not locked(WS,LOCKS)) /\
        SQN' := SQN + 1 /\
        DS' := update(WS,version(RID,SQN'),DS) /\
---        VTS'[RID] == SQN /\  --- we put this equation here to identify any counterexample supporting "wait until"
        VTS'' := insert(RID,SQN',VTS') /\
        PSTS' := PSTS ; txnPropagateSites(TID,WS) .

 crl [fast-commit-failed] :
     < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,READS,WRITES),LOG) >
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : nil,
                                                 writeSet : WS,
                                                 startVTS : VTS >,
                       aborted : TXNS', history : DS, locked : LOCKS >
   =>
     < M : Monitor | clock : GT + 1, log : (TID |-> record(RID,T1,insert(RID,GT,VTS1),false,READS,WRITES),LOG) >
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : emptyTxnList,
                       aborted : (TXNS' ;; < TID : Txn | operations : nil,
                                                         writeSet : WS,
                                                         startVTS : VTS >),
                       history : DS, locked : LOCKS >
     if WS =/= empty /\
        allLocalPreferred(WS,RID,REPLICA-TABLE) /\
        (modified(WS,VTS,DS) or locked(WS,LOCKS)) .


  crl [slow-commit-prepare] :
      < TABLE : Table | table : REPLICA-TABLE >
      < RID : Replica | executing : < TID : Txn | operations : nil,
                                                  writeSet : WS,
                                                  startVTS : VTS >,
                        voteSites : VSTS >
    =>
      < TABLE : Table | table : REPLICA-TABLE >
      < RID : Replica | executing : < TID : Txn | operations : nil,
                                                  writeSet : WS,
                                                  startVTS : VTS >,
                        voteSites : (VSTS ; voteSites(TID,RIDS)) >
      prepareTxn(TID,keys(WS),VTS,RIDS,REPLICA-TABLE,RID)
      if WS =/= empty /\
         (not allLocalPreferred(WS,RID,REPLICA-TABLE)) /\
         RIDS := allPreferredSites(WS,REPLICA-TABLE) /\
         (not (TID in VSTS)) .

   rl [slow-commit-receive-prepare] :
      < RID : Replica | locked : LOCKS,
                        history : DS >
      (msg prepare(TID,KS,VTS) from RID' to RID)
    =>
      if (not locked(KS,LOCKS)) and (not modified(KS,VTS,DS)) 
        then < RID : Replica | locked : (addLock(KS,TID),LOCKS),
                               history : DS >
             (msg prepare-reply(TID,true) from RID to RID')
        else < RID : Replica | locked : LOCKS,
                               history : DS >
             (msg prepare-reply(TID,false) from RID to RID')
      fi .

 crl [slow-commit-receive-prepare-reply] :
     < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | executing : < TID : Txn | operations : nil, writeSet : WS, readSet : RS,
                                                 startVTS : VTS, txnSQN : TXNSQN >,
                       committed : TXNS', aborted : TXNS'', votes : VOTES,
                       voteSites : VSTS, sqn : SQN, history : DS,
                       committedVTS : VTS', locked : LOCKS, 
                       dsSites : PSTS, abortSites : ABORTS >
     (msg prepare-reply(TID,FLAG) from RID' to RID)
   =>
     < TABLE : Table | table : REPLICA-TABLE >
     (if VSTS'[TID] == empty --- all votes received
       then if allYes(TID,VOTES')  --- all yes votes
              then < M : Monitor | clock : GT + 1, log : (TID |-> record(RID,T1,insert(RID,GT,VTS1),true,RS,kvs(WS,version(RID,SQN'))),LOG) >
                   < RID : Replica | executing : emptyTxnList,
                                     committed : (TXNS' ;; < TID : Txn | operations : nil, writeSet : WS, readSet : RS,
                                                                         startVTS : VTS, txnSQN : SQN' >),
                                     aborted : TXNS'', votes : VOTES', voteSites : VSTS', 
                                     sqn : SQN', history : DS', committedVTS : VTS'',
                                     locked : release(TID,LOCKS), dsSites : PSTS', abortSites : ABORTS >
                   propagateTxn(TID,SQN',VTS,WS,allServers(REPLICA-TABLE),RID)       
              else if RIDS =/= empty
                     then < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
                          < RID : Replica | executing : < TID : Txn | operations : nil,
                                                                      writeSet : WS, readSet : RS,
                                                                      startVTS : VTS,
                                                                      txnSQN : TXNSQN >,
                                            committed : TXNS', aborted : TXNS'', votes : VOTES',
                                            voteSites : VSTS', sqn : SQN, history : DS,
                                            committedVTS : VTS', locked : LOCKS, dsSites : PSTS,
                                            abortSites : ABORTS' >
                          propagateAbort(TID,RIDS,RID)  
  --- "remote call" abort; abort the txn locally when receiving all acks to remote calls
                      else < M : Monitor | clock : GT + 1, log : (TID |-> record(RID,T1,insert(RID,GT,VTS1),false,empty,empty),LOG) >
                           < RID : Replica | executing : emptyTxnList,
                                             committed : TXNS',
                                             aborted : (TXNS'' ;; < TID : Txn | operations : nil, writeSet : WS, readSet : RS,
                                                                                startVTS : VTS, txnSQN : TXNSQN >),
                                             votes : VOTES', voteSites : VSTS', sqn : SQN, history : DS,
                                             committedVTS : VTS', locked : LOCKS, dsSites : PSTS,
                                             abortSites : ABORTS > 
                    fi
                  
            fi
       else < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
            < RID : Replica | executing : < TID : Txn | operations : nil, writeSet : WS, readSet : RS,
                                                        startVTS : VTS, txnSQN : TXNSQN >,
                              committed : TXNS', aborted : TXNS'', votes : VOTES',
                              voteSites : VSTS', sqn : SQN, history : DS, committedVTS : VTS',
                              locked : LOCKS, dsSites : PSTS, abortSites : ABORTS >
     fi) 
     if VSTS' := remove(TID,RID',VSTS) /\
        VOTES' := VOTES ; vote(TID,RID',FLAG) /\
        SQN' := SQN + 1 /\
        DS' := update(WS,version(RID,SQN'),DS) /\
---        VTS'[RID] == SQN /\  --- we put this equation here to identify any counterexample supporting "wait until"
        VTS'' := insert(RID,SQN',VTS') /\
        PSTS' := PSTS ; txnPropagateSites(TID,WS) /\
        RIDS := yesSites(TID,VOTES') /\
        ABORTS' := ABORTS ; voteSites(TID,RIDS) .

  --- ??? no need for ack??? The walter paper doesn't talk about it.
  --- ??? Based on my understanding of "remote call", I implement "ack"
  rl [slow-commit-receive-abort] :
     < RID : Replica | locked : LOCKS >
     (msg abort(TID) from RID' to RID)
   =>
     < RID : Replica | locked : release(TID,LOCKS) >  
     (msg aborted(TID) from RID to RID') .

 crl [receive-aborted] :
     < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
     < RID : Replica | executing : < TID : Txn | >, aborted : TXNS', abortSites : ABORTS >
     (msg aborted(TID) from RID' to RID)
   =>
     (if ABORTS'[TID] == empty  --- upon receiving all acks to remote calls, abort the txn locally
       then < M : Monitor | clock : GT + 1, log : (TID |-> record(RID,T1,insert(RID,GT,VTS1),false,empty,empty),LOG) >
            < RID : Replica | executing : emptyTxnList, aborted : (TXNS' ;; < TID : Txn | >),
                              abortSites : ABORTS' >
       else < M : Monitor | clock : GT, log : (TID |-> record(RID,T1,VTS1,false,empty,empty),LOG) >
            < RID : Replica | executing : < TID : Txn | >, aborted : TXNS', abortSites : ABORTS' >
     fi)
     if ABORTS' := remove(TID,RID',ABORTS) .


 crl [receive-propagate-ack] :
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | dsSites : PSTS, vsbSites : VSBS,
                       committed : (TXNS ;; < TID : Txn | writeSet : WS, startVTS : VTS,
                                                          txnSQN : SQN > ;; TXNS'),
                       dsTxns : DSTXNS, gvTxns : GVTXNS >
     (msg propagate-ack(TID) from RID' to RID) 
   => 
     < TABLE : Table | table : REPLICA-TABLE >
     (if dsDurable(TID,PSTS')
       then if RIDS =/= empty
              then < RID : Replica | dsSites : PSTS', vsbSites : VSBS',
                                     committed : (TXNS ;; < TID : Txn | writeSet : WS, startVTS : VTS,
                                                                        txnSQN : SQN > ;; TXNS'),
                                     dsTxns : (TID, DSTXNS), gvTxns : GVTXNS >
                   dsDurableTxn(TID,RIDS,RID)
              else < RID : Replica | dsSites : PSTS', vsbSites : VSBS',
                                     committed : (TXNS ;; < TID : Txn | writeSet : WS, startVTS : VTS,
                                                                        txnSQN : SQN > ;; TXNS'),
                                     dsTxns : (TID, DSTXNS), gvTxns : (TID, GVTXNS) >
            fi
       else < RID : Replica | dsSites : PSTS', vsbSites : VSBS,
                              committed : (TXNS ;; < TID : Txn | writeSet : WS, startVTS : VTS,
                                                                 txnSQN : SQN > ;; TXNS'),
                              dsTxns : DSTXNS, gvTxns : GVTXNS >
     fi)
     if PSTS' := add(TID,keys(WS),RID',REPLICA-TABLE,PSTS)  /\
        (not TID in DSTXNS) /\  --- if TID in DSTXNS, later-coming propagate-ack will be simply ignored
        RIDS := allServers(REPLICA-TABLE) \ RID /\
        VSBS' := VSBS ; voteSites(TID,RIDS) .


 crl [receive-propagate-ack-after-ds-durable-mark] :
     < RID : Replica | dsTxns : DSTXNS >
     (msg propagate-ack(TID) from RID' to RID)
   =>
     < RID : Replica | dsTxns : DSTXNS >
     if TID in DSTXNS .

 crl [receive-visible] :
     < RID : Replica | vsbSites : VSBS,
                       gvTxns : GVTXNS >
     (msg visible(TID) from RID' to RID)
   =>
     (if VSBS'[TID] == empty
       then < RID : Replica | vsbSites : VSBS',
                              gvTxns : (TID, GVTXNS) >
       else < RID : Replica | vsbSites : VSBS',
                              gvTxns : GVTXNS >
     fi)
     if VSBS' := remove(TID,RID',VSBS) .

 crl [receive-propagate-empty-VTS] :
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | gotVTS : VTS',
                       history : DS,
                       recPropTxns : PTXNS >
     (msg propagate(TID,SQN,empty,WS) from RID' to RID)
   =>
     < TABLE : Table | table : REPLICA-TABLE >
     (if RID =/= RID'
       then < RID : Replica | gotVTS : VTS'', 
                              history : DS',
                              recPropTxns : PTXNS' >
            (msg propagate-ack(TID) from RID to RID')
       else < RID : Replica | gotVTS : VTS'', 
                              history : DS,
                              recPropTxns : PTXNS' >
            (msg propagate-ack(TID) from RID to RID')
     fi)
     if PTXNS' := propagatedTxns(TID,SQN,empty) ; PTXNS /\ 
        VTS'' := insert(RID',SQN,VTS') /\
        DS' := update(locRepWS(WS,RID,REPLICA-TABLE),version(RID',SQN),DS) .

 crl [receive-propagate-non-empty-VTS] :
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | gotVTS : VTS', history : DS, recPropTxns : PTXNS >
     (msg propagate(TID,SQN,VTS,WS) from RID' to RID)
   =>
     < TABLE : Table | table : REPLICA-TABLE >
     (if s(VTS'[RID']) == SQN and (VTS' gt VTS)
       then if RID =/= RID'
              then < RID : Replica | gotVTS : VTS'', history : DS',
                                     recPropTxns : PTXNS' >
                   (msg propagate-ack(TID) from RID to RID')
              else < RID : Replica | gotVTS : VTS'', history : DS,
                                     recPropTxns : PTXNS' >
                   (msg propagate-ack(TID) from RID to RID')
            fi
       else < RID : Replica | gotVTS : VTS', history : DS,
                              recPropTxns : PTXNS'' >
     fi)
     if PTXNS' := propagatedTxns(TID,SQN,VTS) ; PTXNS /\
        PTXNS'' := nonPropagatedTxns(TID,SQN,VTS,WS,RID') ; PTXNS /\  
        VTS'' := insert(RID',SQN,VTS') /\
        DS' := update(locRepWS(WS,RID,REPLICA-TABLE),version(RID',SQN),DS) /\
        VTS =/= empty .

  --- ??? Deal with the buffered propagate msgs
  --- ??? recPropTxns may now have nondeterminism
 crl [later-propagate-ack] :
     < TABLE : Table | table : REPLICA-TABLE >
     < RID : Replica | gotVTS : VTS', history : DS,
                       recPropTxns : (nonPropagatedTxns(TID,SQN,VTS,WS,RID') ; PTXNS) >
   =>
     < TABLE : Table | table : REPLICA-TABLE >
     (if RID =/= RID'
       then < RID : Replica | gotVTS : VTS'', history : DS', 
                              recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS) >
            (msg propagate-ack(TID) from RID to RID')
       else < RID : Replica | gotVTS : VTS'', history : DS,
                              recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS) >
            (msg propagate-ack(TID) from RID to RID')
     fi)
     if s(VTS'[RID']) == SQN /\
        VTS' gt VTS /\
        VTS'' := insert(RID',SQN,VTS') /\
        DS' := update(locRepWS(WS,RID,REPLICA-TABLE),version(RID',SQN),DS) .


 crl [receive-ds-durable-visible] :
     < M : Monitor | clock : GT, log : (TID |-> record(RID',T1,VTS1,true,READS,WRITES),LOG) >
     < RID : Replica | recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS),
                       recDurableTxns : DTXNS, committedVTS : VTS', locked : LOCKS >
     (msg ds-durable(TID) from RID' to RID)
   =>
     < M : Monitor | clock : GT + 1, log : (TID |-> record(RID',T1,insert(RID,GT,VTS1),true,READS,WRITES),LOG) >
     < RID : Replica | recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS),
                       recDurableTxns : (durableTxns(TID) ; DTXNS),
                       committedVTS : insert(RID',SQN,VTS'), locked : release(TID,LOCKS) >
     (msg visible(TID) from RID to RID')
     if VTS' gt VTS /\ s(VTS'[RID']) == SQN .

 crl [receive-ds-durable-not-visible-not-match-condition] :
     < RID : Replica | recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS),
                       recDurableTxns : DTXNS, committedVTS : VTS' >
     (msg ds-durable(TID) from RID' to RID)
   =>
     < RID : Replica | recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS),
                       recDurableTxns : (nonDurableTxns(TID,RID') ; DTXNS),
                       committedVTS : VTS' >
     if ((not VTS' gt VTS) or s(VTS'[RID']) =/= SQN) . 

  --- ??? the replica has got the propagate msg but failed to ack it
  rl [receive-ds-durable-not-visible-non-propagated-1] :
     < RID : Replica | recPropTxns : (nonPropagatedTxns(TID,SQN,VTS,WS,RID') ; PTXNS),
                       recDurableTxns : DTXNS >
     (msg ds-durable(TID) from RID' to RID)
   =>
     < RID : Replica | recPropTxns : (nonPropagatedTxns(TID,SQN,VTS,WS,RID') ; PTXNS),
                       recDurableTxns : (nonDurableTxns(TID,RID') ; DTXNS) > .

  --- ??? the replica hasn't got the propagate msg
 crl [receive-ds-durable-not-visible-non-propagated-2] :
     < RID : Replica | recPropTxns : PTXNS, recDurableTxns : DTXNS >
     (msg ds-durable(TID) from RID' to RID)
   =>
     < RID : Replica | recPropTxns : PTXNS,
                       recDurableTxns : (nonDurableTxns(TID,RID') ; DTXNS) >
     if not TID in PTXNS .

  --- ??? Deal with the buffered ds-durable msgs
  --- ??? recDurableTxns may now have nondeterminism
 crl [later-visible] :
     < M : Monitor | clock : GT, log : (TID |-> record(RID',T1,VTS1,true,READS,WRITES),LOG) >
     < RID : Replica | recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS),
                       recDurableTxns : (nonDurableTxns(TID,RID') ; DTXNS),
                       committedVTS : VTS', locked : LOCKS >
   =>  
     < M : Monitor | clock : GT + 1, log : (TID |-> record(RID',T1,insert(RID,GT,VTS1),true,READS,WRITES),LOG) >
     < RID : Replica | recPropTxns : (propagatedTxns(TID,SQN,VTS) ; PTXNS),
                       recDurableTxns : (durableTxns(TID) ; DTXNS),
                       committedVTS : insert(RID',SQN,VTS'), locked : release(TID,LOCKS) >
     (msg visible(TID) from RID to RID')
     if VTS' gt VTS /\ s(VTS'[RID']) == SQN .
  
endom) 


