load initial-states

mod ROLA-ANALYSIS is
  including INITIAL-STATES .
  including APMAUDE .
  including MODEL-CHECKER .

  subsort Config < State .

  eq LIMIT = 10000000.0 .

  op initConfig : -> Config .
  eq initConfig = run(initState,LIMIT) .

  ops x y z : -> Key .
  ops tb r1 r2 r3 t1 t2 t3 t4 : -> Address .
  ops xl yl zl : -> LocalVar .
  
  --- init(RTX,WTX,RWTX,REPLS,KEYS,ROPS,WOPS,RWOPS,KAD) 
  eq initState = init(0,0,400,100,50,2,2,4,zipf) .


  --- Metrics
  vars T T' T1 T2 NUMBER : Float .
  var C : Config .
  vars M TID : Address .
  vars RECORD RECORD' : Record . 
  vars READS WRITES : VersionSet .
  var FLAG : Bool .

  --- Throughput
  op totalRunTime : Record -> Float .
  op trt : Record Float -> Float .
  eq totalRunTime(RECORD) = trt(RECORD,0.0) .
  eq trt((record(TID,T1,T2,READS,WRITES,FLAG) ; RECORD),T) = 
       if T2 > T
         then trt(RECORD,T2)
         else trt(RECORD,T)
       fi .
  eq trt(noRecord,T) = T .
         
  op throughput : Config -> Float .
  eq throughput(< M : Monitor | log: RECORD > C) = committedNumber(RECORD) / totalRunTime(RECORD) .

  op committedNumber : Record -> Float .
  op $committedNumber : Record Float -> Float .
  eq committedNumber(RECORD) = $committedNumber(RECORD,0.0) .
  eq $committedNumber((record(TID,T1,T2,READS,WRITES,true) ; RECORD),NUMBER) = 
       $committedNumber(RECORD,NUMBER + 1.0) .
  eq $committedNumber((record(TID,T1,T2,READS,WRITES,false) ; RECORD),NUMBER) = 
       $committedNumber(RECORD,NUMBER) .
  eq $committedNumber(noRecord,NUMBER) = NUMBER .

  --- Commit Rate
  op commitRate : Config -> Float .
  eq commitRate(< M : Monitor | log: RECORD > C) = committedNumber(RECORD) / totalNumber(RECORD) .

  op totalNumber : Record -> Float .
  op $totalNumber : Record Float -> Float .
  eq totalNumber(RECORD) = $totalNumber(RECORD,0.0) .
  eq $totalNumber((record(TID,T1,T2,READS,WRITES,FLAG) ; RECORD),NUMBER) = 
       $totalNumber(RECORD,NUMBER + 1.0) .
  eq $totalNumber(noRecord,NUMBER) = NUMBER .  

  --- Avg Latency
  op avgLatency : Config -> Float .
  eq avgLatency(< M : Monitor | log: RECORD > C) = totalLatency(RECORD) / committedNumber(RECORD) .
  
  op totalLatency : Record -> Float .
  op $totalLatency : Record Float -> Float .
  eq totalLatency(RECORD) = $totalLatency(RECORD,0.0) .
  eq $totalLatency((record(TID,T1,T2,READS,WRITES,true) ; RECORD),NUMBER) =
       $totalLatency(RECORD,NUMBER + T2 - T1) .
  eq $totalLatency((record(TID,T1,T2,READS,WRITES,false) ; RECORD),NUMBER) = 
       $totalLatency(RECORD,NUMBER) .
  eq $totalLatency(noRecord,NUMBER) = NUMBER .

  --- PVESTA interfaces
  eq val(0,C) = throughput(C) .
  eq val(1,C) = avgLatency(C) .
  eq val(2,C) = commitRate(C) .


  vars TID1 TID2 : Address .
  vars T1' T2' : Float .
  vars RS1 RS2 WS1 WS2 : VersionSet .
  vars VX VX' VY VY' : Value .
  vars TSX TSX' TSY TSY' : Timestamp .
  vars MDX MDX' MDY MDY' : KeySet .
  vars LOG LOG' LOG'' : Record .
  vars X Y : Key .
  vars VS VS' : VersionSet .

  --- Standard model checking
  --- RA
  op fracRead : Record -> Bool .
 ceq fracRead(LOG ; record(TID1,T1,T1',RS1,(version(X,VX,TSX,MDX),version(Y,VY,TSY,MDY)),true) ; LOG' ;
                    record(TID2,T2,T2',(version(X,VX,TSX,MDX),version(Y,VY',TSY',MDY')),WS2,true) ; LOG'') = true 
     if TSY' less-than TSY .
 ceq fracRead(LOG ; record(TID2,T2,T2',(version(X,VX,TSX,MDX),version(Y,VY',TSY',MDY')),WS2,true) ; LOG' ;
                    record(TID1,T1,T1',RS1,(version(X,VX,TSX,MDX),version(Y,VY,TSY,MDY)),true) ; LOG'') = true 
     if TSY' less-than TSY .
  eq fracRead(LOG) = false [owise] .

  --- No Lost Update
  op lu : Record -> Bool .
 ceq lu(LOG ; record(TID1,T1,T1',RS1,WS1,true) ; LOG' ; record(TID2,T2,T2',RS2,WS2,true) ; LOG'') = true
     if intersectRead(RS1,RS2) /\ intersectWrite(WS1,WS2) .
  eq lu(LOG) = false [owise] .

  op intersectRead : VersionSet VersionSet -> Bool .
  eq intersectRead((version(X,VX,TSX,MDX),VS),(version(X,VX,TSX,MDX),VS')) = true .
  eq intersectRead(VS,VS') = false .

  op intersectWrite : VersionSet VersionSet -> Bool .
  eq intersectWrite((version(X,VX,TSX,MDX),VS),(version(X,VX',TSX',MDX'),VS')) = true .
  eq intersectWrite(VS,VS') = false .
      
endm

---set clear rules off .
---rewrite initConfig .
---rewrite totalRunTime?(initConfig) .
---search [1] initConfig =>! C:Config < M:Address : Monitor | log: LOG:Record > such that fracRead(LOG) .
search [1] initConfig =>! C:Config < M:Address : Monitor | log: LOG:Record > such that lu(LOG) .

