load replica-table

(omod WALTER-AUX is
  including CLIENT-REPLICA .
  including MESSAGE .
  including REPLICA-TABLE .
  including VERSION-WALTER .
  including VALUES-NAT .

  op f : -> Nat .  --- disaster-safe tolerance parameter

  vars TID RID RID' TABLE M : Oid .
  vars RIDS DSTXNS GVTXNS : OidSet .
  vars TXNS TXNS' TXNS'' : ObjectList .
  var OPS : OperationList .
  var K : Key .
  vars V V' : Value .
  var X : LocalVar .
  var WS : WriteSet .
  var VARS : LocalVars .
  vars RS READS WRITES : ReadSet .
  var REPLICA-TABLE : ReplicaTable .
  var VERSION : Version .
  vars VTS VTS' VTS'' VTS1 : VectorTimestamp .
  vars DS DS' : Datastore .
  vars VVS VVS' : ValueVersionList .
  vars SQN SQN' TXNSQN CLOCK GT T1 T2 T3 T4 : Nat .
  var EXPR : Expression .
  var KS : KeySet .
  var LOCKS : Locks .
  vars VSTS VSTS' VSBS VSBS' ABORTS ABORTS' : VoteSites .
  vars RIDSS RIDSS' : OidList .
  var RT : KeyReplicas .
  vars VOTES VOTES' : Vote .
  var FLAG : Bool .
  vars PSTS PSTS' : PropagateSites .
  vars PTXNS PTXNS' PTXNS'' : PropagatedTxns .
  vars DTXNS DTXNS' : DurableTxns .
  var LOG : Log .


  --- choose the last update in the history visible to startVTS
  op choose : VectorTimestamp ValueVersionList -> ValueVersion .
  eq choose(VTS,(VVS < V,version(RID,SQN) >)) = 
       if VTS[RID] == 0
         then choose(VTS,VVS)
         else if SQN <= VTS[RID]
                then < V,version(RID,SQN) >
                else choose(VTS,VVS)
              fi 
       fi [owise] .
  --- as of now we return default value if none found
  --- namely, < [0], version(0,0) >
  --- assume the initial sqn is 0
  eq choose(VTS,nil) = < [0], version(0,0) > .
  eq choose(empty,VVS) = < [0],version(0,0) > .  --- the first incoming read 
  eq choose(VTS,undefined) = < [0], version(0,0) > .


  ---??? the explanation of "merge" in the Walter paper is vague...
  op merge : Key ValueVersion Datastore -> Datastore .
  eq merge(K,< V,VERSION >,(K |-> (VVS < V,VERSION > VVS'),DS)) = K |-> (VVS < V,VERSION > VVS'),DS .
 ceq merge(K,< V,VERSION >,(K |-> VVS,DS)) = K |-> (VVS < V,VERSION >),DS 
       if (not occurs(< V,VERSION >, VVS)) .
  eq merge(K,< V,VERSION >,DS) = K |-> < V,VERSION >, DS [owise] .  


  op modified : WriteSet VectorTimestamp Datastore -> Bool .
 ceq modified((K |-> V,WS),VTS,(K |-> (VVS < V',version(RID,SQN) > VVS'),DS)) = true
       if SQN > VTS[RID] .
  eq modified(WS,VTS,DS) = false [owise] .

  op modified : KeySet VectorTimestamp Datastore -> Bool .
 ceq modified((K,KS),VTS,(K |-> (VVS < V',version(RID,SQN) > VVS'),DS)) = true
       if SQN > VTS[RID] .
  eq modified(KS,VTS,DS) = false [owise] .

  op locked : WriteSet Locks -> Bool .
  eq locked((K |-> V,WS),(lock(TID,K),LOCKS)) = true .
  eq locked(WS,LOCKS) = false [owise] .
 
  op locked : KeySet Locks -> Bool .
  eq locked((K,KS),(lock(TID,K),LOCKS)) = true .
  eq locked(KS,LOCKS) = false [owise] .

  op update : WriteSet Version Datastore -> Datastore .
  eq update((K |-> V,WS),version(RID,SQN),(K |-> VVS,DS)) = 
       update(WS,version(RID,SQN),(K |-> (VVS < V,version(RID,SQN) >),DS)) .
  eq update((K |-> V,WS),version(RID,SQN),DS) = 
       update(WS,version(RID,SQN),(K |-> < V,version(RID,SQN) >,DS)) [owise] .
  eq update(empty,VERSION,DS) = DS .

  op kvs : WriteSet Version -> ReadSet .
  eq kvs((K |-> V,WS),VERSION) = 
       kvs(WS,VERSION), versionRead(K,VERSION) .
  eq kvs(empty,VERSION) = empty .

  
  ---??? Fig.13 in the walter paper says propagating a txn to ALL servers, why ALL?
  ---??? shouldn't all replicas concerning keys in the write set be enough?
  ---??? As explained in Section 4.4, ALL is for disaster-safe durability
  op propagateTxn : Oid Nat VectorTimestamp WriteSet OidSet Oid -> Configuration .
  eq propagateTxn(TID,SQN,VTS,WS,(RID, RIDS),RID') = 
       propagateTxn(TID,SQN,VTS,WS,RIDS,RID')
       (msg propagate(TID,SQN,VTS,WS) from RID' to RID) .
  eq propagateTxn(TID,SQN,VTS,WS,empty,RID') = none .
  

  --- Walter runs 2pc among preferred sites of updated objects
  --- the key set sent to a server is a subset of the entire key set where each key's 
  --- preferred site is that server
  op prepareTxn : Oid KeySet VectorTimestamp OidSet ReplicaTable Oid -> Configuration .
  eq prepareTxn(TID,KS,VTS,(RID, RIDS),REPLICA-TABLE,RID') =
       prepareTxn(TID,KS,VTS,RIDS,REPLICA-TABLE,RID')
       (msg prepare(TID,onSite(KS,RID,REPLICA-TABLE),VTS) from RID' to RID) .
  eq prepareTxn(TID,KS,VTS,empty,REPLICA-TABLE,RID') = none .
  


  op onSite : KeySet Oid ReplicaTable -> KeySet .
  eq onSite((K,KS),RID,[replicatingSites(K,RID RIDSS) ;; RT]) = 
       K, onSite(KS,RID,[RT]) .
  eq onSite(KS,RID,[RT]) = empty [owise] .
  
  op propagateAbort : Oid OidSet Oid -> Configuration .
  eq propagateAbort(TID,(RID, RIDS),RID') = 
       propagateAbort(TID,RIDS,RID')
       (msg abort(TID) from RID' to RID) .
  eq propagateAbort(TID,empty,RID') = none .
  
  
  op addLock : KeySet Oid -> Locks .
  eq addLock((K,KS),TID) = lock(TID,K), addLock(KS,TID) .
  eq addLock(empty,TID) = empty . 

  op release : Oid Locks -> Locks .
  eq release(TID,(lock(TID,K),LOCKS)) =
       release(TID,LOCKS) .
  eq release(TID,LOCKS) = LOCKS [owise] .

  op remove : Oid Oid VoteSites -> VoteSites .
  eq remove(TID,RID,(voteSites(TID,(RID, RIDS)) ; VSTS)) =
       voteSites(TID,RIDS) ; VSTS .
  eq remove(TID,RID,VSTS) = VSTS [owise] .
  
  op _`[_`] : VoteSites Oid -> OidSet .
  eq (voteSites(TID,RIDS) ; VSTS)[TID] = RIDS . 

  op yesSites : Oid Vote -> OidSet .
  eq yesSites(TID,(vote(TID,RID',true) ; VOTES)) = RID', yesSites(TID,VOTES) .
  eq yesSites(TID,VOTES) = empty [owise] .

  op allYes : Oid Vote -> Bool .
  eq allYes(TID,(vote(TID,RID',false) ; VOTES)) = false .
  eq allYes(TID,VOTES) = true [owise] .

  op txnPropagateSites : Oid WriteSet -> PropagateSites .
  eq txnPropagateSites(TID,(K |-> V,WS)) = 
       propagateSites(TID,K,empty) ; txnPropagateSites(TID,WS) .
  eq txnPropagateSites(TID,empty) = noPS . 
  
  op dsDurable : Oid PropagateSites -> Bool .  --- filter for TID
  eq dsDurable(TID,(propagateSites(TID,K,RIDS) ; PSTS)) = | RIDS | >= (f + 1) and dsDurable(TID,PSTS) .
  eq dsDurable(TID,PSTS) = true [owise] .

  op add : Oid KeySet Oid ReplicaTable PropagateSites -> PropagateSites .  --- TID, RID
  eq add(TID,(K,KS),RID,[replicatingSites(K,RIDSS RID RIDSS') ;; RT],(propagateSites(TID,K,RIDS) ; PSTS)) =
       add(TID,KS,RID,[RT],(propagateSites(TID,K,(RID,RIDS)) ; PSTS)) .
  eq add(TID,KS,RID,[RT],PSTS) = PSTS [owise] .

  
  op dsDurableTxn : Oid OidSet Oid -> Configuration .
  eq dsDurableTxn(TID,(RID,RIDS),RID') =
       dsDurableTxn(TID,RIDS,RID')
       (msg ds-durable(TID) from RID' to RID) .
  eq dsDurableTxn(TID,empty,RID') = none .
  

  ---??? the walter paper doesn't mention how to compare two VectorTimestamps
  ---??? so I define based on my understanding
  op _gt_ : VectorTimestamp VectorTimestamp -> Bool .
 ceq ((RID |-> SQN), VTS) gt ((RID |-> SQN'), VTS') = false 
       if SQN < SQN' .
 ceq VTS gt ((RID |-> SQN'), VTS') = false
       if not $hasMapping(VTS,RID) .  
  eq VTS gt VTS' = true [owise] .

  
  op _in_ : Oid PropagatedTxns -> Bool .
  eq TID in (propagatedTxns(TID,SQN,VTS) ; PTXNS) = true .
  eq TID in (nonPropagatedTxns(TID,SQN,VTS,WS,RID') ; PTXNS) = true .
  eq TID in PTXNS = false [owise] .

  op _in_ : Oid VoteSites -> Bool .
  eq TID in (voteSites(TID,RIDS) ; VSTS) = true .
  eq TID in VSTS = false [owise] .
endom)
